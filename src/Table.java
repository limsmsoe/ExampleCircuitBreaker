/*
 * Course: SWE2410-121
 * Fall 2024-2025
 * File header contains class Table
 * Name: Sam Lim
 * Created 11/12/2024
 */
import java.util.Random;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Course SWE2410-121
 * Fall 2024-2025
 * Class Table Purpose: A simulation of a table which keeps track of how many guests can sit at a given table
 *
 * @author Sam Lim
 * @version created on 10/11/2024 9:10am
 */
public class Table {
    private final int totalSeats;
    private int availableSeats;
    private final Object availableSeatsLock = new Object();
    private final boolean isBar;

    public Table(int totalSeats, boolean isBar) {
        this.totalSeats = totalSeats;
        availableSeats = this.totalSeats;
        this.isBar = isBar;
    }

    public Table(int totalSeats) {
        this(totalSeats, false);
    }

    public Table() {
        this((new Random()).nextInt(config.tableSeatMax - config.tableSeatMin + 1) + config.tableSeatMin, false);
    }

    private ScheduledExecutorService scheduler;
    private final AtomicInteger taskCount = new AtomicInteger(0);

    /**
     * Seats a single guest for a certain duration of time
     * @param duration how long the guest will occupy the seat at the table
     */
    public void seatCustomer(long duration) {
        // Lazy initialization of ScheduledExecutorService generated by Copilot with prompt
        // "Make the scheduler automatically create and shutdown as needed"
        synchronized (availableSeatsLock) { // Assures that availableSeats is not being modified at the same time
            if (availableSeats > 0) {
                availableSeats--;
                if (scheduler == null || scheduler.isShutdown()) {
                    scheduler = Executors.newScheduledThreadPool(1);
                }
                taskCount.incrementAndGet();
                scheduler.schedule(() -> {
                    synchronized (availableSeatsLock) {
                        availableSeats++;
                        if (taskCount.decrementAndGet() == 0) {
                            scheduler.shutdown();
                        }
                    }
                }, duration, TimeUnit.MILLISECONDS);
            }
        }
    }

    public int getAvailableSeats() {
        return availableSeats;
    }
    public int getTotalSeats() {
        return totalSeats;
    }

    public boolean isBar() {
        return isBar;
    }


}
